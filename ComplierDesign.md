# Complier设计 #

总述：
关于整个的设计中，我一开始最有迷惑的地方在于活动记录和符号表，很容易混。但是在后来逐渐清晰了他们各自的功能：
- 活动记录说白了就是一个数据段，即内存中的一部分，存储着各种变量的值。所以说实际上活动记录不是在程序中写个vector向量就可以解决的问题，它是依赖于四元式或者目标代码而变化的。

- 符号表本身除了会存入常量的值外，其余任何变量的值都不会被存入，只会存变量的地址，变量的地址是基于它上面只有在存储分配中为各个变量分配到的地址。

- 由于MIPS指令的解释器不是由我们写的，但是我们仍然需要维护活动记录，在这种情况下，有些请

## 语法分析 ##

### Parser ###

## 四元式 ##

参照龙书的设计，我想给我的编译器设定的四元式如下：

四元式的结构如下：
- opcode（指令码）
- result (指令执行结果存放的地方)
- arg1 (操作数1)
- arg2 (操作数2)

约定如下：如果只需要单个操作符，那么优先使用result，然后是arg1，第二个操作符默认为0，这一点可以使用默认参数列表做到

- result = arg1 op arg2
	- ADD  X,Y,                                                                                                              Z 
	- SUB X,Y,Z
	- MULT X,Y,Z
	- DIV   X,Y,Z
		- y和z进行op二目操作符运算，结果存在x中
- x = op y
	- MINUS X,Y,0
		- op是单目操作符，比如负号这样的操作符，执行完后再把y的值赋给x。
- x = y
	- ASS X,Y,0
		- 赋值操作符，把y的值赋给x
- goto L
	- JUMP X,0,0
 		- 无条件跳转到标号L(result)所表示的地址
- if x goto L
	- BR Y,X,0
		- 如果满足条件x，则跳转到标号L(result，Y)所表示的地址
- if Falsex goto L
	- BRN Y,X,0
		- 如果不满足条件x，则跳转到标号L(result，Y)所表示的地址
- call p,n
	- CALL 0,P,N
		- 调用函数，n为参数个数
- y = call p,n
	- CALA Y,P,N
		- 函数调用得到的返回值，n为参数个数，实参通过栈来传递
- setret a
	- SETRET a,0,0
		- 设置本函数的返回值为A，这时候要填到活动记录中去
- x = y [ i ] 
	- INDEX x,y,i
		- 设置x为距离y处i个内存单元的的位置中存放的值

## 符号表的管理 ##

符号表是用来记录源程序中各种**标识符**的特性信息的表格，所以也称作名字特性表。包括的属性有：
- name(名字)
- kind(种类)
	- proc
	- func
	- const
	- var
	- array
	- paraaddr
	- paravalue
- type(类型-仅对func,var,array,varpara,valuepara有效)
	- int
	- char
	- string
- level(层次)
- addr(分配的空间的首地址)
- value(存放const的值)

**Notes**:
1. 符号表中数组的addr处填入的应当是数组的首地址
2. 符号表中

符号表同时要使用分程序表**btab**：



## 活动记录 ##

在函数被调用的时候，会发生什么？
在中间代码的层次上来说，我们首先应该保存寄存器的状态。
问题更多的地方集中于符号表的填写，是否说在定义完成之后，符号表就不可用了呢？

符号表在语法分析中起到的作用包括：
1. 静态类型检查，判断程序中对变量的引用和计算是否是类型正确的，并将一些非同类型的自动做类型转换，比如将字符做减法运算时，字符与整数进行运算时等。
2. 判断是否有重名与变量名冲突。

符号表是否要销毁呢？
是否需要重建取决于初始的符号表中有什么东西，按照书上的说法，栈式符号表是会动态增加与减少的，